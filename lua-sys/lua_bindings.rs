/* automatically generated by rust-bindgen */

pub type va_list = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State {
    _unused: [u8; 0],
}
pub type lua_Number = f64;
pub type lua_Integer = libc::c_longlong;
pub type lua_KContext = isize;
pub type lua_CFunction =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State) -> libc::c_int>;
pub type lua_KFunction = ::std::option::Option<
    unsafe extern "C" fn(L: *mut lua_State, status: libc::c_int, ctx: lua_KContext) -> libc::c_int,
>;
pub type lua_Reader = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        ud: *mut libc::c_void,
        sz: *mut usize,
    ) -> *const libc::c_char,
>;
pub type lua_Writer = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        p: *const libc::c_void,
        sz: usize,
        ud: *mut libc::c_void,
    ) -> libc::c_int,
>;
pub type lua_Alloc = ::std::option::Option<
    unsafe extern "C" fn(
        ud: *mut libc::c_void,
        ptr: *mut libc::c_void,
        osize: usize,
        nsize: usize,
    ) -> *mut libc::c_void,
>;
extern "C" {
    pub fn lua_newstate(f: lua_Alloc, ud: *mut libc::c_void) -> *mut lua_State;
}
extern "C" {
    pub fn lua_close(L: *mut lua_State);
}
extern "C" {
    pub fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
}
extern "C" {
    pub fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction;
}
extern "C" {
    pub fn lua_version(L: *mut lua_State) -> *const lua_Number;
}
extern "C" {
    pub fn lua_absindex(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_gettop(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_settop(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_pushvalue(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_rotate(L: *mut lua_State, idx: libc::c_int, n: libc::c_int);
}
extern "C" {
    pub fn lua_copy(L: *mut lua_State, fromidx: libc::c_int, toidx: libc::c_int);
}
extern "C" {
    pub fn lua_checkstack(L: *mut lua_State, n: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_xmove(from: *mut lua_State, to: *mut lua_State, n: libc::c_int);
}
extern "C" {
    pub fn lua_isnumber(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_isstring(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_iscfunction(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_isinteger(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_isuserdata(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_type(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_typename(L: *mut lua_State, tp: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_tonumberx(
        L: *mut lua_State,
        idx: libc::c_int,
        isnum: *mut libc::c_int,
    ) -> lua_Number;
}
extern "C" {
    pub fn lua_tointegerx(
        L: *mut lua_State,
        idx: libc::c_int,
        isnum: *mut libc::c_int,
    ) -> lua_Integer;
}
extern "C" {
    pub fn lua_toboolean(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_tolstring(
        L: *mut lua_State,
        idx: libc::c_int,
        len: *mut usize,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_rawlen(L: *mut lua_State, idx: libc::c_int) -> usize;
}
extern "C" {
    pub fn lua_tocfunction(L: *mut lua_State, idx: libc::c_int) -> lua_CFunction;
}
extern "C" {
    pub fn lua_touserdata(L: *mut lua_State, idx: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn lua_tothread(L: *mut lua_State, idx: libc::c_int) -> *mut lua_State;
}
extern "C" {
    pub fn lua_topointer(L: *mut lua_State, idx: libc::c_int) -> *const libc::c_void;
}
extern "C" {
    pub fn lua_arith(L: *mut lua_State, op: libc::c_int);
}
extern "C" {
    pub fn lua_rawequal(L: *mut lua_State, idx1: libc::c_int, idx2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_compare(
        L: *mut lua_State,
        idx1: libc::c_int,
        idx2: libc::c_int,
        op: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_pushnil(L: *mut lua_State);
}
extern "C" {
    pub fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
}
extern "C" {
    pub fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
}
extern "C" {
    pub fn lua_pushlstring(
        L: *mut lua_State,
        s: *const libc::c_char,
        len: usize,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_pushstring(L: *mut lua_State, s: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_pushvfstring(
        L: *mut lua_State,
        fmt: *const libc::c_char,
        argp: va_list,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_pushfstring(L: *mut lua_State, fmt: *const libc::c_char, ...)
        -> *const libc::c_char;
}
extern "C" {
    pub fn lua_pushcclosure(L: *mut lua_State, fn_: lua_CFunction, n: libc::c_int);
}
extern "C" {
    pub fn lua_pushboolean(L: *mut lua_State, b: libc::c_int);
}
extern "C" {
    pub fn lua_pushlightuserdata(L: *mut lua_State, p: *mut libc::c_void);
}
extern "C" {
    pub fn lua_pushthread(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_getglobal(L: *mut lua_State, name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn lua_gettable(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_getfield(L: *mut lua_State, idx: libc::c_int, k: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn lua_geti(L: *mut lua_State, idx: libc::c_int, n: lua_Integer) -> libc::c_int;
}
extern "C" {
    pub fn lua_rawget(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_rawgeti(L: *mut lua_State, idx: libc::c_int, n: lua_Integer) -> libc::c_int;
}
extern "C" {
    pub fn lua_rawgetp(L: *mut lua_State, idx: libc::c_int, p: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn lua_createtable(L: *mut lua_State, narr: libc::c_int, nrec: libc::c_int);
}
extern "C" {
    pub fn lua_newuserdata(L: *mut lua_State, sz: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn lua_getmetatable(L: *mut lua_State, objindex: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_getuservalue(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_setglobal(L: *mut lua_State, name: *const libc::c_char);
}
extern "C" {
    pub fn lua_settable(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_setfield(L: *mut lua_State, idx: libc::c_int, k: *const libc::c_char);
}
extern "C" {
    pub fn lua_seti(L: *mut lua_State, idx: libc::c_int, n: lua_Integer);
}
extern "C" {
    pub fn lua_rawset(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_rawseti(L: *mut lua_State, idx: libc::c_int, n: lua_Integer);
}
extern "C" {
    pub fn lua_rawsetp(L: *mut lua_State, idx: libc::c_int, p: *const libc::c_void);
}
extern "C" {
    pub fn lua_setmetatable(L: *mut lua_State, objindex: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_setuservalue(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_callk(
        L: *mut lua_State,
        nargs: libc::c_int,
        nresults: libc::c_int,
        ctx: lua_KContext,
        k: lua_KFunction,
    );
}
extern "C" {
    pub fn lua_pcallk(
        L: *mut lua_State,
        nargs: libc::c_int,
        nresults: libc::c_int,
        errfunc: libc::c_int,
        ctx: lua_KContext,
        k: lua_KFunction,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_load(
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut libc::c_void,
        chunkname: *const libc::c_char,
        mode: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_dump(
        L: *mut lua_State,
        writer: lua_Writer,
        data: *mut libc::c_void,
        strip: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_yieldk(
        L: *mut lua_State,
        nresults: libc::c_int,
        ctx: lua_KContext,
        k: lua_KFunction,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_resume(L: *mut lua_State, from: *mut lua_State, narg: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_status(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_isyieldable(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_gc(L: *mut lua_State, what: libc::c_int, data: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_error(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_next(L: *mut lua_State, idx: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn lua_concat(L: *mut lua_State, n: libc::c_int);
}
extern "C" {
    pub fn lua_len(L: *mut lua_State, idx: libc::c_int);
}
extern "C" {
    pub fn lua_stringtonumber(L: *mut lua_State, s: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn lua_getallocf(L: *mut lua_State, ud: *mut *mut libc::c_void) -> lua_Alloc;
}
extern "C" {
    pub fn lua_setallocf(L: *mut lua_State, f: lua_Alloc, ud: *mut libc::c_void);
}
pub type lua_Hook =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State, ar: *mut lua_Debug)>;
extern "C" {
    pub fn lua_getstack(L: *mut lua_State, level: libc::c_int, ar: *mut lua_Debug) -> libc::c_int;
}
extern "C" {
    pub fn lua_getinfo(
        L: *mut lua_State,
        what: *const libc::c_char,
        ar: *mut lua_Debug,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lua_getlocal(
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_setlocal(
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_getupvalue(
        L: *mut lua_State,
        funcindex: libc::c_int,
        n: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_setupvalue(
        L: *mut lua_State,
        funcindex: libc::c_int,
        n: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn lua_upvalueid(L: *mut lua_State, fidx: libc::c_int, n: libc::c_int)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn lua_upvaluejoin(
        L: *mut lua_State,
        fidx1: libc::c_int,
        n1: libc::c_int,
        fidx2: libc::c_int,
        n2: libc::c_int,
    );
}
extern "C" {
    pub fn lua_sethook(L: *mut lua_State, func: lua_Hook, mask: libc::c_int, count: libc::c_int);
}
extern "C" {
    pub fn lua_gethook(L: *mut lua_State) -> lua_Hook;
}
extern "C" {
    pub fn lua_gethookmask(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn lua_gethookcount(L: *mut lua_State) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lua_Debug {
    pub event: libc::c_int,
    pub name: *const libc::c_char,
    pub namewhat: *const libc::c_char,
    pub what: *const libc::c_char,
    pub source: *const libc::c_char,
    pub currentline: libc::c_int,
    pub linedefined: libc::c_int,
    pub lastlinedefined: libc::c_int,
    pub nups: libc::c_uchar,
    pub nparams: libc::c_uchar,
    pub isvararg: libc::c_char,
    pub istailcall: libc::c_char,
    pub short_src: [libc::c_char; 60usize],
    pub i_ci: *mut CallInfo,
}
#[test]
fn bindgen_test_layout_lua_Debug() {
    assert_eq!(
        ::std::mem::size_of::<lua_Debug>(),
        128usize,
        concat!("Size of: ", stringify!(lua_Debug))
    );
    assert_eq!(
        ::std::mem::align_of::<lua_Debug>(),
        8usize,
        concat!("Alignment of ", stringify!(lua_Debug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).namewhat as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(namewhat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).what as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(what)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).source as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).currentline as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(currentline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).linedefined as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(linedefined)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).lastlinedefined as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(lastlinedefined)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).nups as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(nups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).nparams as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(nparams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).isvararg as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(isvararg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).istailcall as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(istailcall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).short_src as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(short_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lua_Debug>())).i_ci as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(i_ci)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct luaL_Reg {
    pub name: *const libc::c_char,
    pub func: lua_CFunction,
}
#[test]
fn bindgen_test_layout_luaL_Reg() {
    assert_eq!(
        ::std::mem::size_of::<luaL_Reg>(),
        16usize,
        concat!("Size of: ", stringify!(luaL_Reg))
    );
    assert_eq!(
        ::std::mem::align_of::<luaL_Reg>(),
        8usize,
        concat!("Alignment of ", stringify!(luaL_Reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Reg>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Reg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Reg>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Reg),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    pub fn luaL_checkversion_(L: *mut lua_State, ver: lua_Number, sz: usize);
}
extern "C" {
    pub fn luaL_getmetafield(
        L: *mut lua_State,
        obj: libc::c_int,
        e: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_callmeta(
        L: *mut lua_State,
        obj: libc::c_int,
        e: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_tolstring(
        L: *mut lua_State,
        idx: libc::c_int,
        len: *mut usize,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn luaL_argerror(
        L: *mut lua_State,
        arg: libc::c_int,
        extramsg: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_checklstring(
        L: *mut lua_State,
        arg: libc::c_int,
        l: *mut usize,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn luaL_optlstring(
        L: *mut lua_State,
        arg: libc::c_int,
        def: *const libc::c_char,
        l: *mut usize,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn luaL_checknumber(L: *mut lua_State, arg: libc::c_int) -> lua_Number;
}
extern "C" {
    pub fn luaL_optnumber(L: *mut lua_State, arg: libc::c_int, def: lua_Number) -> lua_Number;
}
extern "C" {
    pub fn luaL_checkinteger(L: *mut lua_State, arg: libc::c_int) -> lua_Integer;
}
extern "C" {
    pub fn luaL_optinteger(L: *mut lua_State, arg: libc::c_int, def: lua_Integer) -> lua_Integer;
}
extern "C" {
    pub fn luaL_checkstack(L: *mut lua_State, sz: libc::c_int, msg: *const libc::c_char);
}
extern "C" {
    pub fn luaL_checktype(L: *mut lua_State, arg: libc::c_int, t: libc::c_int);
}
extern "C" {
    pub fn luaL_checkany(L: *mut lua_State, arg: libc::c_int);
}
extern "C" {
    pub fn luaL_newmetatable(L: *mut lua_State, tname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn luaL_setmetatable(L: *mut lua_State, tname: *const libc::c_char);
}
extern "C" {
    pub fn luaL_testudata(
        L: *mut lua_State,
        ud: libc::c_int,
        tname: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn luaL_checkudata(
        L: *mut lua_State,
        ud: libc::c_int,
        tname: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn luaL_where(L: *mut lua_State, lvl: libc::c_int);
}
extern "C" {
    pub fn luaL_error(L: *mut lua_State, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn luaL_checkoption(
        L: *mut lua_State,
        arg: libc::c_int,
        def: *const libc::c_char,
        lst: *const *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_fileresult(
        L: *mut lua_State,
        stat: libc::c_int,
        fname: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_execresult(L: *mut lua_State, stat: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn luaL_ref(L: *mut lua_State, t: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn luaL_unref(L: *mut lua_State, t: libc::c_int, ref_: libc::c_int);
}
extern "C" {
    pub fn luaL_loadfilex(
        L: *mut lua_State,
        filename: *const libc::c_char,
        mode: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_loadbufferx(
        L: *mut lua_State,
        buff: *const libc::c_char,
        sz: usize,
        name: *const libc::c_char,
        mode: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_loadstring(L: *mut lua_State, s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn luaL_newstate() -> *mut lua_State;
}
extern "C" {
    pub fn luaL_len(L: *mut lua_State, idx: libc::c_int) -> lua_Integer;
}
extern "C" {
    pub fn luaL_gsub(
        L: *mut lua_State,
        s: *const libc::c_char,
        p: *const libc::c_char,
        r: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn luaL_setfuncs(L: *mut lua_State, l: *const luaL_Reg, nup: libc::c_int);
}
extern "C" {
    pub fn luaL_getsubtable(
        L: *mut lua_State,
        idx: libc::c_int,
        fname: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn luaL_traceback(
        L: *mut lua_State,
        L1: *mut lua_State,
        msg: *const libc::c_char,
        level: libc::c_int,
    );
}
extern "C" {
    pub fn luaL_requiref(
        L: *mut lua_State,
        modname: *const libc::c_char,
        openf: lua_CFunction,
        glb: libc::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct luaL_Buffer {
    pub b: *mut libc::c_char,
    pub size: usize,
    pub n: usize,
    pub L: *mut lua_State,
    pub initb: [libc::c_char; 8192usize],
}
#[test]
fn bindgen_test_layout_luaL_Buffer() {
    assert_eq!(
        ::std::mem::size_of::<luaL_Buffer>(),
        8224usize,
        concat!("Size of: ", stringify!(luaL_Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<luaL_Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(luaL_Buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Buffer>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Buffer>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Buffer>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Buffer>())).L as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<luaL_Buffer>())).initb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(initb)
        )
    );
}
extern "C" {
    pub fn luaL_buffinit(L: *mut lua_State, B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_prepbuffsize(B: *mut luaL_Buffer, sz: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn luaL_addlstring(B: *mut luaL_Buffer, s: *const libc::c_char, l: usize);
}
extern "C" {
    pub fn luaL_addstring(B: *mut luaL_Buffer, s: *const libc::c_char);
}
extern "C" {
    pub fn luaL_addvalue(B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_pushresult(B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_pushresultsize(B: *mut luaL_Buffer, sz: usize);
}
extern "C" {
    pub fn luaL_buffinitsize(
        L: *mut lua_State,
        B: *mut luaL_Buffer,
        sz: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn luaopen_base(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_coroutine(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_table(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_io(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_os(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_string(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_utf8(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_bit32(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_math(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_debug(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaopen_package(L: *mut lua_State) -> libc::c_int;
}
extern "C" {
    pub fn luaL_openlibs(L: *mut lua_State);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallInfo {
    pub _address: u8,
}
